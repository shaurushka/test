
# firstDBcell <- firstDBCell
# secondDBcell <- secondDBCell
# columnsToCalcDistanceOn <- distanceCols
makeFusionForCell <- function(firstDBcell, secondDBcell, columnsToCalcDistanceOn) {
  #set.seed(NULL)
  set.seed(123)
  distance <- rdist(firstDBcell[, columnsToCalcDistanceOn], secondDBcell[, columnsToCalcDistanceOn])
  x <- transport(secondDBcell$magnitude / sum(secondDBcell$magnitude) * sum(firstDBcell$magnitude), firstDBcell$magnitude, t(distance)^2)
  firstDBcell <- cbind(firstDBcell, data.frame(idRow = 1 : nrow(firstDBcell)))
  secondDBcell <- cbind(secondDBcell, data.frame(idRow = 1 : nrow(secondDBcell)))

  firstDBHash <- data.frame(idFirst = firstDBcell$id, idRowFirst = firstDBcell$idRow)
  secondDBHash <- data.frame(idSecond = secondDBcell$id, idRowSecond = secondDBcell$idRow)

  fusionForCell <- merge(x, firstDBHash, by.x = 'to', by.y = 'idRowFirst')
  fusionForCell <- merge(fusionForCell, secondDBHash, by.x = 'from', by.y = 'idRowSecond')
  fusionForCell <- fusionForCell %>% select(idFirst, idSecond, mass)
  fusionForCell <- cbind(fusionForCell, data.frame(adjCoeff = sum(secondDBcell$magnitude) / sum(firstDBcell$magnitude)))
  
  dbNames <- c(firstDBcell[1,]$type, secondDBcell[1, ]$type)
  colnames(fusionForCell)[1 : 2] <- paste("id", dbNames, sep = "")
  return (fusionForCell)
}


makeFusionOnGroupOfVars <- function(dbsConcatenation, cellCols, distanceCols, firstDBNameInFusionDB) {
  # dbsConcatenation <- matchedDB
  # distanceCols <- distCols
  dbsConcatenation <- dbsConcatenation %>% mutate(group = group_indices(group_by_all(dbsConcatenation[cellCols])))
  matchedDB <- NULL
  unmatchedDB <- NULL
  groupInd <- 1
  for (groupInd in unique(dbsConcatenation$group)) {
    firstDBCell <- dbsConcatenation %>% filter(group == groupInd & type == firstDBNameInFusionDB) 
    secondDBCell <- dbsConcatenation %>% filter(group == groupInd & type != firstDBNameInFusionDB)
    if ((nrow(firstDBCell) * nrow(secondDBCell) == 0) && (nrow(firstDBCell) + nrow(secondDBCell) > 0)) {
      unmatchedDB <- appendToTableByRow(firstDBCell, unmatchedDB)
      unmatchedDB <- appendToTableByRow(secondDBCell, unmatchedDB)
    } else {
      fusionForCell <- makeFusionForCell(firstDBCell, secondDBCell, distanceCols)
      matchedDB <- appendToTableByRow(fusionForCell, matchedDB)
    }
  }
  unmatchedDB$group <- NULL
  return (list(matched = matchedDB, unmatched = unmatchedDB))
}

makeFusionOnNewVarBasedOnOldVars <- function(dbsConcatenation, oldCellCols, newCellCol, distanceCols, firstDBNameInFusionDB) {
  # distanceCols <- distCols
  # dbsConcatenation <- matchedDB
  # oldCellCols <- cellCols[-length(cellCols)]
  # newCellCol <- cellCols[length(cellCols)]
  dbsConcatenation$group <- group_indices(group_by_all(dbsConcatenation[oldCellCols]))
  dbsConcatenation$newCellCol <- dbsConcatenation[[newCellCol]]
  
  matchedDB <- NULL
  unmatchedDB <- NULL 
  groupInd <- 1
  for (groupInd in unique(dbsConcatenation$group)) {
    dbsConcatenationGroup <- dbsConcatenation %>% filter(group == groupInd)
    tableFreq <- data.frame(table(dbsConcatenationGroup[c("type", "newCellCol")]))
    
    if (min(tableFreq$Freq) > 0) {
      # newCellGroupValue <- dbsConcatenationGroup$newCellCol[1]
      for (newCellGroupValue in unique(dbsConcatenationGroup$newCellCol)) {
        Cell <- dbsConcatenationGroup[dbsConcatenationGroup$newCellCol == newCellGroupValue, ]
        firstDBCell <- Cell %>% filter(type == firstDBNameInFusionDB)
        secondDBCell <- Cell %>% filter(type != firstDBNameInFusionDB)
        fusionForCell <- makeFusionForCell(firstDBCell, secondDBCell, distanceCols)
        matchedDB <- appendToTableByRow(fusionForCell, matchedDB)
      }
    } else {
      unmatchedDB <- appendToTableByRow(dbsConcatenationGroup, unmatchedDB)
    }
  }
  unmatchedDB$group <- NULL
  unmatchedDB$newCellCol <- NULL
  return (list(matched = matchedDB, unmatched = unmatchedDB))
}

# unmatchedDBOnCurrentLevel <- levelFusion$unmatched 
addUnmatchedOnCurrentLevelIDsToFusionDB <- function(unmatchedDBOnCurrentLevel, firstDBNameInFusionDB, 
                                                    fusionDBFromPrevLevel = NULL, fusionDB = NULL) {
  firstDBUnmatchedIDs <- unmatchedDBOnCurrentLevel %>% filter(type == firstDBNameInFusionDB) %>% select(id)
  firstDBFusionOld <- merge(fusionDBFromPrevLevel, firstDBUnmatchedIDs, 
                            by.x = colnames(fusionDBFromPrevLevel)[1], by.y = "id")
  
  secondDBUnmatchedIDs <- unmatchedDBOnCurrentLevel %>% filter(type != firstDBNameInFusionDB) %>% select(id)
  secondDBFusionOld <- merge(fusionDBFromPrevLevel, secondDBUnmatchedIDs, 
                             by.x = colnames(fusionDBFromPrevLevel)[2], by.y = "id")
  
  unmatchedIDsFusionOld <- unique(rbind(firstDBFusionOld, secondDBFusionOld))
  
  return (appendToTableByRow(unmatchedIDsFusionOld, fusionDB))
} 

selectNextCellColInd <- function(db, cellCols, newCellColsCandidates) {
  maxCellSize <- -1 
  nextCellColInd <- NULL
  for (ind in 1: length(newCellColsCandidates)) {
    tableFreq <- data.frame(table(db[c("type", cellCols, newCellColsCandidates[ind])]))
    
    if (min(tableFreq$Freq) > maxCellSize) { 
      nextCellColInd <- ind
    }
  }
  return (nextCellColInd)
}

# fullCellColsListSize <- varsGroups$maxCellColsCount
# varsList <-  varsGroups$varsList
# dbsConcatenation <- fullDB
# firstDBNameInFusionDB <- firstDBNameInFused
makeFusionOnAllVars <- function(dbsConcatenation, varsList, fullCellColsListSize, day, firstDBNameInFusionDB) {
  fusionDB <- NULL
  fusionDBFromPrevLevel <- NULL
  matchedDB <- dbsConcatenation
  regionInd <- which(varsList == "region")
  regionCellCol <- varsList[regionInd]
  if (length(regionInd) > 0) {
    varsList <- varsList[-regionInd]
  }
  baseColsCount <- 4
  cellCollsFullList <- varsList[(baseColsCount + 1) : (fullCellColsListSize - 1)]
  
  varsCount <- length(varsList)
  pureDistCols <- NULL
  if (varsCount > fullCellColsListSize) {
    pureDistCols <- varsList[fullCellColsListSize : varsCount]
  }
  for (cellColsListSize in 1 : (fullCellColsListSize - 1)) {
    print (paste("Level:", cellColsListSize, "; Objects to split = ", nrow(matchedDB), sep = " "))
    if (cellColsListSize == 1) {
      cellCols <- c(regionCellCol, "sex", "ageGroup")
      distCols <- varsList[3 : varsCount]
      levelFusion <- makeFusionOnGroupOfVars(matchedDB, cellCols, distCols, firstDBNameInFusionDB)
    } else {
      if (cellColsListSize <= baseColsCount) {
        cellCols <- c(regionCellCol, varsList[1 : cellColsListSize])
        distCols <- varsList[(cellColsListSize + 1) : varsCount]
      } else {
        newCellColInd <- selectNextCellColInd(matchedDB, cellCols, cellCollsFullList)
        cellCols <- c(cellCols, cellCollsFullList[newCellColInd])
        cellCollsFullList <- cellCollsFullList[-newCellColInd]
        # print (cellCollsFullList)
        distCols <- c(cellCollsFullList, pureDistCols)
      }
      levelFusion <- makeFusionOnNewVarBasedOnOldVars(matchedDB, 
                                                      head(cellCols, -1), 
                                                      tail(cellCols, 1), 
                                                      distCols, 
                                                      firstDBNameInFusionDB)
    }
    if (!is.null(levelFusion$unmatched) && (nrow(levelFusion$unmatched) > 0) && (!is.null(fusionDBFromPrevLevel))) {
      fusionDB <- addUnmatchedOnCurrentLevelIDsToFusionDB(levelFusion$unmatched, firstDBNameInFusionDB, 
                                                          fusionDBFromPrevLevel = fusionDBFromPrevLevel, 
                                                          fusionDB = fusionDB)
    } 
    if (is.null(levelFusion$matched) || (nrow(levelFusion$matched) == 0)) {
      return (list(cellCols = head(cellCols, -1), db = fusionDB))
    }
    fusionDBFromPrevLevel <- levelFusion$matched
    firstDB <- merge(dbsConcatenation %>% filter(type == firstDBNameInFusionDB), 
                     unique(fusionDBFromPrevLevel[1]), by.x = "id", by.y = colnames(fusionDBFromPrevLevel)[1])
    secondDB <- merge(dbsConcatenation %>% filter(type != firstDBNameInFusionDB), 
                      unique(fusionDBFromPrevLevel[2]), by.x = "id", by.y = colnames(fusionDBFromPrevLevel)[2])
    matchedDB <- rbind(firstDB, secondDB)
  }
  
  if (!is.null(fusionDBFromPrevLevel)) {
    fusionDB <- appendToTableByRow(fusionDBFromPrevLevel, fusionDB)
  }
  return (list(cellCols = cellCols, db = fusionDB))
}

